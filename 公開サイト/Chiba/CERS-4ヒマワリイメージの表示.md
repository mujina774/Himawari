## 2 ひまわり8号グリッドデータの描画

### 2.1 ひまわり8号グリッドデータについて
簡単に言うと、気象衛星ひまわり8号からデジタルカメラで撮影した地球のカラー写真。 ただし、画像として表示するためにはデータ処理が必要

ひまわり8号の「カメラ」はAHI（Advanced Himawari Imager）と呼ばれている。 AHIは可視～赤外領域の16色（16バンド）を記録することができる。

#### グリッドデータとは
 - ひまわり8号の標準データはAHIの画像座標上に並んでおり、 緯度経度を得るためには幾何補正が必要。
 - グリッドデータは、ひまわり8号のデータを等緯度経度グリッド上に並べたデータ。
 - グリッドデータにはこれまでの静止気象衛星データとの関連性から気象庁とは異なるルールでバンド名が付けられている。 
 
表2.1にひまわり8号のバンド名とグリッドデータのバンド名の対応を示す。（例えばひまわり8号のバンド03はグリッドデータのext01に対応する。）
 
#### 表 2.1. ひまわり8号のバンド名とグリッドデータのバンド名

| ひまわり8号バンド名| グリッドデータ|バンド名 |中心波長（μm）| グリッド間隔（度 ）| 有効ビット数|
| --- | --- | --- | --- | --- | --- |
|01 | vis | 01 |0.47 |0.01| 11|
|02 | |02| 0.51| 0.01| 11|
|03 | ext| 01| 0.64| 0.005| 11|
|04| vis |03| 0.86| 0.01| 11|
|05 | sir|01| 1.6| 0.02 |11|
|06| | 02| 2.3| 0.02| 11|
|07| | tir|05 | 3.9 | 0.02 |14|
|08| |06 |6.2| 0.02| 11|
|09| |07 |6.9 |0.02| 11|
|10| |08 |7.3 |0.02 |12|
|11| |09 |8.6 |0.02 |12|
|12| |10| 9.6| 0.02| 12|
|13| |01| 10.4| 0.02 |12|
|14| |02| 11.2| 0.02 |12|
|15| |03| 12.4 |0.02| 12|
|16| |04 |13.3| 0.02| 12|

※ グリッド間隔0.01度は空間分解能約1 kmに相当する。


 - グリッドデータのファイル名はyyyymmddhhnn.XXX.ZZ.cccc.geossのようになっている。ここで、yyyy、mm、dd、hh、nnはそれぞれ年、月、日、時、分、XXX.ZZはグリッドデータのバンド名、ccccは観測領域名。
    - 【例】201605120400.ext.01.fld.geoss

全球スキャン（フルディスク:fld）グリッドデータの観測範囲は東経85°～205°、北緯60°～南緯60°（120°× 120°）であり、各バンドの空間分解能に合わせたグリッド（格子）に区切られている。これではデータサイズが大き過ぎるため、本演習では東経138°～141°、北緯34.5°～37.5°（3°× 3°）の関東周辺（kanto）を切り出したデータを使用する（図2.1参照）。グリッドデータには等緯度経度グリッド上のひまわり8号観測値（DN値）が西から東、北から南の順に2バイト符号なし整数のバイナリ形式で記録されている（バイトオーダーはビッグエンディアン）。

ここでは例として青バンド（vis.01）のグリッドデータ（"201605120400.vis.01.kanto.geoss"）を使う。
デフォルトのバイトオーダーは計算機に依存するが、フォーマット文字の前に '<'、'>'を置くとそれぞれリトルエンディアン、ビッグエンディアンを指定できる。

```
data = np.fromfile('201605120400.vis.01.kanto.geoss',dtype='>u2')
```

```
data.shape

(90000,)

data = data.reshape(300,300)
```

```
plt.imshow(data);
```

・カラースケールの下限、上限はそれぞれvmin、vmaxオプションで与えられる。
・横軸、縦軸の値はextentオプションで左、右、下、上の座標を与えられる。

表2.2 imshowの主なオプション
|オプション| 説明 |値|
| --- | --- | --- |
|vmin| カラースケールの最小値 |例： 100|
|vmax| カラースケールの最大値 |例： 500|
|extent |画像の左右下上座標 |例： (138,141,34.5,37.5)|
|cmap: |カラーマップ|cm.jet|
| | |cm.gray|
| | |etc. |
|interpolation |補間方法| 'none'|
| | |'nearest'|
| | |'bilinear'|
| | |etc.|
|origin| 画像の上下起点| 'upper'（上→下）|
| | |'lower'（下→上）|


```
plt.imshow(data,vmin=100,vmax=500,extent=(138,141,34.5,37.5),interpolation='none')
plt.colorbar();
```

## 3 グリッドデータの校正

```
data = np.fromfile('201605120400.vis.01.kanto.geoss',dtype='>u2').reshape(300,300)
```

　サンプルプログラムセットには DN値を物理量に変換するためのルックアップテーブルが含まれてお
り、ここではこれを使って校正を行う。
　　ルックアップテーブルのファイル名はグリッドデータのバンド名と同じであり、内容にはDN値と物理量
（バンド1～6：反射率、単位は％、バンド7～16：輝度温度、単位はK）が書かれている。
ルックアップテーブル（vis.01）の内容
|0列目（DN値）| 1列目（反射率）|
| --- | --- |
|0 |-1.176471|
|1 |-1.117647|
|2 |-1.058824|
|·||
|·||
|·||
|2047| 119.235294|

☞ ルックアップテーブルは以下のようなコードで読み込むことが出来る。
入力コード：
```
count,value = np.loadtxt('vis.01', unpack = True)
```
◎ loadtxtにunpack=Trueのオプションを付けて0列目、1列目をそれぞれcount、valueに代入している。
◎ このオプションを付けないとloadtxtは1つの2次元ndarrayを返す。

```
plt.plot(count,value)
plt.xlabel('DN')
plt.ylabel('Reflectance (%)')
plt.grid(True)
```
### 3.4 校正
　-　ルックアップテーブルを使うとDN値（count）に対応する物理量（value）が直ちに分かる。
　-　今の場合、配列valueのインデックス（0から始まる要素番号）は対応するcountの値に等しい。
　-　Numpyの配列（ndarray）はインデックスを指定することによって要素を取り出せるため、 valueのインデックスを指定することによってDN値に対応する物理量を得ることができる。
◎ 例えば、value[0]でvalueの最初の要素を取り出せる。
◎ value[[0,1,2]]のように要素のインデックスを入れた配列を使って複数の要素も取り出せる。

```
count,value = np.loadtxt('vis.01', unpack = True)
```

```
plt.plot(count,value)
plt.xlabel('DN')
plt.ylabel('Reflectance (%)')
plt.grid(True)
```
☞ DN値が0、500、1000、1500、2000に対応する物理量を求めてみよう！
入力コード：
```
value[[0,500,1500,2000]]
```

☞ 同様に、dataの中身はDN値なので、valueのインデックスに指定すれば物理量に変換できる。
入力コード：
```
value_b = value[data]
```

## 3.5 描画
☞ 校正済みデータをプロット
入力コード：
```
plt.imshow(value_b, vmin = 5,vmax = 30, extent = (138, 141, 34.5, 37.5), interpolation = 'none')
plt.colorbar();
```
DN値が物理量に変わった

## 4 グリッドデータのRGB合成
### 4.3 グリッドデータの読み込み
☞ 青、緑、赤バンド（vis.01、vis.02、ext.01）のグリッドデータを読み込んでみよう！
ここでは校正まで一気に行い、さらに0.01を掛けることで反射率の百分率を割合に変換する。
赤バンド（ext.01）だけ空間分解能が異なることに注意！

loadtxtにusecols=(1,)オプションを付けて1列目だけを読み込んでいる。
usecolsオプションの値にはタプル（Pythonの配列の一種）を与えるが、
要素数が1のタプルは要素の後にコンマを付けるという規則がある。

入力コード：
```
fnam_b = '201605120400.vis.01.kanto.geoss'
fnam_g = '201605120400.vis.02.kanto.geoss'
fnam_r = '201605120400.ext.01.kanto.geoss'
value_b = np.loadtxt('vis.01',usecols=(1,))[np.fromfile(fnam_b,dtype='>u2').reshape(300,300)]*0.01
value_g = np.loadtxt('vis.02',usecols=(1,))[np.fromfile(fnam_g,dtype='>u2').reshape(300,300)]*0.01
value_r = np.loadtxt('ext.01',usecols=(1,))[np.fromfile(fnam_r,dtype='>u2').reshape(600,600)]*0.01
```

### 4.4 ビニング
RGB合成を行うために、赤バンドの空間分解能を他のバンドに合わせるため、縦、横のデータ数をそれぞれ半分にする。1つおきに間引くだけでも良いが、ここでは縦、横それぞれで2画素ずつの平均値を使うすることで2×2のビニングをする。

 - 配列value_rの形状（shape）は、 (600,600)となっている。これは、次元数が2であり、0番目と1番目の次元（0番目のaxisは画像の縦方向、1番目のaxisは画像の横方向）の要素数がどちらも600であることを示している。
 1. それぞれのaxisの要素数を(300,2)のように分割する。 （全体のshapeは(300,2,300,2)となる。）
 2. 横方向について2画素毎に平均値を計算する。平均値はmean()の`axis`を指定することで横方向のaxisだけで平均値を計算する。
     - mean(-1)
 3. 縦方向について2画素毎に平均値を計算する。縦方向のaxisなので`mean(1)`のように指定する。
 4. 平均値の計算結果は浮動小数点数なので、astype('u2')によって 符号なし整数に変換する。この変換は小数点以下切り捨てのため、変換の前に0.5を加えて四捨五入されるようにしている。
 
なお、今は全球グリッドデータから関東周辺を切り出したデータを使っているので問題ないが、全球グリッドデータをそのまま使う場合はメモリ容量が足りないなどの問題が生じる可能性がある。その場合、以下のようにまず符号なし整数データの平均値を求めてから校正した方が良いかもしれない。
```
data = (np.fromfile(fnam_r,dtype='>u2').reshape(300,2,300,2).mean(-1).mean(1)+0.5).astype('u2')
value_r = np.loadtxt('ext.01',usecols=(1,))[data]
```

 - ちなみに、単に1つおきに間引くだけであれば以下のコードでよい。
```
value_r = value_r[::2,::2]
```

```
value_r = value_r.reshape(300, 2, 300, 2).mean(-1).mean(1)
```

4.5 RGB合成
☞ 赤、緑、青の3バンドのデータはnp.dstackを使って連結できる。
入力コード：
```
rgb = np.dstack((value_r, value_g, value_b))
```
In [6]:
☞ データサイズを確かめてみよう！
入力コード：
```
rgb.shape
```
```
value_r = value_r.reshape(300,2,300,2).mean(-1).mean(1)
rgb = np.dstack((value_r,value_g,value_b))
```

合成して出来たRGBデータは今まで同様imshowを使って描画できるが、 RGBカラーで正しく表示でき
るのは1バイト符号なし整数、または0以上1以下の浮動小数点数データに限られる。
反射率は本来0以上1以下の値を取るが、ノイズ等のためにその範囲を逸脱することもあり得る。
☞ 以下のコードで反射率を0から1までの範囲に限定する。
入力コード：
```
rgb = rgb.clip(0,1)
```

### 4.6 描画
☞ まずはimshowを使ってRGBデータをそのまま描画してみよう！
入力コード：
```
plt.imshow(rgb);
```
RGBデータをそのまま描画すると、しばしば暗い画像が得られる。原因としては、
 - 信号強度が小さい
 - ディスプレイの特性
が考えられる。
☞ 信号強度を確認するために、各色の反射率のヒストグラムを確認してみよう！
入力コード：
```
plt.hist(value_b.flatten(),bins=100)
plt.hist(value_g.flatten(),bins=100)
plt.hist(value_r.flatten(),bins=100)
```

```
Out[7]: (300, 300, 3)
rgb.shape
rgb = rgb.clip(0,1)
```

☞ 信号強度の最小値～最大値が0～1の範囲に収まるようにオフセットやゲインを調節してみよう！
入力コード：
```
rgb2 = np.dstack((value_r*5,value_g*5,value_b*5))
rgb2[(rgb2.max(axis=2) > 1.0)] = 1.0
plt.imshow(rgb2);
```
 - 反射率の値はどの色もだいたい0.2より小さいので、1行目で各色を5倍にしている。
  2行目では、画素毎にR、G、Bの反射率の最大値を求め、最大値が1より大きい場合はその画素を「白」にするためにR、G、Bの全反射率を1に修正している。
  
ディスプレイの特性として、信号強度と明るさは必ずしも比例しない。この特性は のようなガンマ補正によって補正できる。標準的なディスプレイの の値としては2.2程度が適当である。
☞ RGBデータにガンマ補正をかけてみよう！
入力コード：
```
plt.imshow(np.power(rgb,1.0/2.2));  
```

## 5 ひまわり8号NetCDFデータの描画
日本域および機動観測域のひまわり8号データにはNetCDF形式のものが用意されている。このデータは等緯度経度座標系かつ校正済みのため、簡単に取り扱うことが出来る。

### 5.1 ひまわり8号NetCDFデータについて
NetCDF（Network Common Data Form）データ形式は多次元配列データの格納に適したデータ形式の一種であり、HDF（Hierarchical Data Format）と並んで衛星観測データの保存に広く使われている。NetCDFには自己記述的でポータブルという特徴があり、あらかじめどのようなデータが入っているか知らなくても決められた手順に従って読み出すことができる。現在のNetCDFはバージョン4が主流であり、PythonではnetCDF4というモジュールを使って扱える。

ひまわり8号のNetCDFデータは観測バンド毎の空間分解能に応じた等緯度経度座標系になっており、各座標の物理量（バンド1～6：反射率，バンド7～16：輝度温度）が格納されている。NetCDFデータのファイル名はNC_H08_yyyymmdd_hhnn_Bbb_cccc_Rjj.ncのようになっており、yyyy、mm、dd、hh、nn、bb、cccc、jjにはそれぞれ年、月、日、時、分、バンド、観測領域、空間分解能に基づく値が入っている。

from netCDF4 import Dataset
In [2]:

### 5.3 NetCDFデータの読み込み
☞ ここでは例として近赤外バンド（バンド4）のNetCDFデータ
（"NC_H08_20160512_0400_B04_JP01_R10.nc"）を使う。 以下のようなコマンドでファイルを読み込み用にオープンする。
入力コード：
nc = Dataset('NC_H08_20160512_0400_B04_JP01_R10.nc','r')
In [3]:
☞ データを変数に読み込んでみよう！バンド1〜バンド6までは'albedo'、バンド7〜バンド16までは
'tbb'という変数名になっている。
入力コード：
val = nc.variables['albedo'][:]
In [4]:
%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
from netCDF4 import Dataset
nc = Dataset('NC_H08_20160512_0400_B04_JP01_R10.nc','r')
val = nc.variables['albedo'][:]
☞ どんな変数が読み込まれたか確かめてみよう！
入力例：
val.shape
In [5]:
☞ 緯度経度を読み込んでみよう！ 緯度、経度はそれぞれ'latitude'、'longitude'という変数名に
なっている。
入力コード：
lat = nc.variables['latitude'][:]
lon = nc.variables['longitude'][:]
In [6]:
☞ どんな変数が読み込まれたか確かめてみよう！
入力例：
lat.shape
In [7]:
☞ 読み終わったらファイルを閉じる。
入力コード：
nc.close()
In [8]:
5.4 描画
☞ Matplotlibのimshowを使って2次元データを描画する。
入力コード：
plt.imshow(val,extent=(lon[0],lon[-1],lat[-1],lat[0]),interpolation='none')
plt.colorbar();
Out[5]: (2701, 3301)
Out[7]: (2701,)
val.shape
lat = nc.variables['latitude'][:]
lon = nc.variables['longitude'][:]
lat.shape
nc.close()
In [9]: plt.imshow(val,extent=(lon[0],lon[-1],lat[-1],lat[0]),interpolation='none')
plt.colorbar();